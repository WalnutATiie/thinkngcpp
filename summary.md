# summary找工作技能树
## 1. Data Structure
### 1.1 线性表、链表, 队列, 堆栈
线性表
链表: 链表相加（进位与长度不一的边界问题）、链表部分翻转（给定区间翻转）、链表去重（删除节点）、链表划分（快速排序）、链表公共节点（链表长度，遍历）  
队列：图的拓扑排序（DAG）、最短路径条数（单源最短路径退化成广度优先搜索）  
堆栈：括号匹配（栈）、逆波兰表达式（栈）、树的三种遍历的递归与非递归形式（后序遍历非递归，双栈）  
### 1.2 字符串
字符串处理（学会借助std::string与STL中的api）  
字符串循环移位（三次拷贝、(x'y')'=yx）  
LCS、LIS（动态规划、二维长度数组、滚动数组、LIS转化成LCS）  
字符串全排列（递归、有重复字母递归、非递归借助字典序下一个排列、哈希降低时间复杂度）、字典序的下一个排列  
字符串编辑距离（动态规划）
字符串旋转  
最长回文子串（Manacher算法）  
atoi实现       
KMP  
DFA、NFA与正则表达式  
海量字符串还是要借助于Trie树、哈希、BF    
### 1.3数组
天平称量问题（理论下界、3^n>=12*2）  
局部最大值（二分查找）  
第一个缺失的整数（循环不变式）  
旋转数组的最小值（二分查找）  
寻找0子数组（和数组相邻元素差的绝对值的最小值）  
最大子数组和（DP）  
荷兰国旗问题（快速排序中的partition思想）  
Cantor数组  
排序数组最大间隔  
子集和数问题    
### 1.4 树
树转换成二叉树（左孩子右兄弟）  
二叉查找树：增删改查（删右子树最左子孙代替删除位置）  
先序中序后序层次遍历：递归、非递归；先中求后、中后求先  
平衡二叉树：  
- 四种分类：LL、LR、RL、RR  
- 四种旋转：左旋和右旋、单旋转和双旋转  
- 增删改查

堆
B树及其变种：分裂合并节点、B树与B+树区别  
其他树：RB-tree、区间树、二项堆、fibonacci堆
应用：huffman树、字典树(双数组字典树)、线段树、并查集  
#### trie树
字典树对应有限状态自动机    
双数组字典树（待总结）  
### 1.5 图
并查集  
图的存储：链接表、链接矩阵、稀疏图存储  
最短路径：Dijkstra、Floyd、Bellman-Ford  
最小生成树：Prim、Kruskal、带权的最小生成树  
图搜索：DFS、BFS、A*、alpha/beta剪枝 
拓扑排序   
最大流最小割 
回路问题：欧拉图、哈密顿图、TSM  
二分图匹配   
### 1.6 哈希表
常用哈希函数：直接地址法、平方取中法、折叠法、取余法  
字符串的哈希函数：字符串->整数，BKDR哈希，AP哈希
冲突解决：开放定址法、链地址法、再哈希法
实践：使用BKDRhash作为基础的哈希函数；使用链地址法作为冲突处理方法，实现哈希表的插入与查找工作   
应用：哈希分片：Round Robin、Virtual Box、一致哈希  
### 1.7 Data Structure in Big Data
bloom filter、bitmap  
skiplist  
LSM树  
一致哈希 Cuckoo哈希  
### 1.8 排序
插入排序  
选择排序  
冒泡排序  
shell排序  
堆排序  
归并排序  
快速排序  
基数排序  
桶排序  
外部排序  
复杂度、稳定性比较
## 2. Algorithm
### 2.1 初等数论
素数与整数唯一分解  
最大公约数与最小公倍数  
高精度加减乘除
进制转换  
### 2.2 组合数学
加法与乘法原理  
Fibonacci数：O(n)、O(logn)  
Catalan数：矩阵连乘的计算次序、合法出栈次序、圆桌握手、二叉排序数总数、凸多边形三角划分  
排列组合  
### 2.3 概率统计
古典概率模型  
抽样原理  
### 2.4 递归与分治
递归  
分治：最大最小值、矩阵乘法、骑士周游问题、大整数乘法、棋盘覆盖问题  
### 2.5 贪心
背包问题  
机器任务调度算法：多机调度问题、活动安排问题  
### 2.6 动态规划
最优子结构  
递推表达式  
空间换时间  
应用：矩阵连乘问题、LCS、LIS、多段图最短路径、资源分配问题
### 2.7 搜索技术
盲目搜索算法：二分搜索、DFS、BFS  
回溯法：八皇后问题及其并行求解  
启发式搜索：A*算法
博弈问题：博弈树  
alpha-beta剪枝
### 2.8 手写代码
字符串：编辑距离、最长公共子串、最长公共子序列
链地址法哈希表，BKDR哈希函数  
所有排序算法  
单例模式  
智能指针简单实现  
strcpy,itoa,
## 3.Cpp
### 3.1 语言基础
基本数据类型：基本数据类型的种类、整型几种形式与区别、常量与变量  
操作符：优先级，前自增与后自增，三元运算符  
变量：左值与右值、变量初始化方式、变量声明与定义、变量作用域、变量的存储类型  
引用：引用的概念、const与非const引用  
枚举类型、结构体、共用体
C与C++的区别和联系  
编程规范：匈牙利命名法  
const与#define的区别  
mutable关键字  
C与C++中const的区别  
sizeof对齐规则  
sizeof与strlen：类型所占内存大小；以\0结尾的字符串长度  
位运算：判断一个数X是否是2^N次方，实现加法运算，交换a,b，
### 3.2 流程控制
条件语句  
循环语句  
switch语句  
递归语句  
### 3.3 输入输出
输入输出流：概念，如何重载输入输出流  
文件输入、输出：文件输入输出的方式  
### 3.4 预处理  
宏定义、宏定义的展开、宏定义与typedef  
include  
内联函数  
### 3.5 指针与引用
指针初始化与赋值  
const对象的指针和const指针  
数组指针和指针数组  
函数指针  
void*  
this指针  
指针与句柄  
指针和引用的区别    
值传递、地址传递、引用传递
### 3.6 函数  
函数与作用域、形参与实参、引用形参与指针形参、不确定个数参数  
类成员函数、类静态函数  
函数重载与运算符重载
函数匹配二义性处理  
### 3.7 面向对象
面向对象、面向过程、函数式编程  
封装、继承、多态  
类、抽象类  
类成员的访问控制、静态类成员    
类创建时默认生成的函数  
构造函数：赋值函数和copy构造函数、成员初始化列表、
析构函数  
友元函数与友元类    
重载与覆盖  
私有继承、虚函数继承与虚继承、多重继承  
虚函数与纯虚函数 虚函数指针与虚函数表 
运算符重载与RTTI  
构造函数与析构函数的调用时机  
### 3.8 模板与泛型编程
[函数模板与类模板](http://blog.csdn.net/welcome_xu/article/details/7554595)  
[typename](http://baike.baidu.com/link?url=F3AXPc2imfxBPi7M_RqKlqWmldrFN4QSw4-g7MQ0DdO3YlYDrsRD_AzsYiBFuAx8meUhj-pDluLoXtjZm1WVz_)关键字  
函数模板的类型推断  
[函数模板重载](https://github.com/WalnutATiie/thinkngcpp/blob/master/code/C05/MinTest.cpp)  

### 3.9 异常处理
抛出异常与捕获异常、异常匹配  
标准异常std::exception  
异常使用场景  
### 3.10 C++11新特性
long long类型  
nullptr表示空指针  
constexpr用于表示常量表达式。  
noexcept可以用于指示一个函数是否会抛出异常，同时可以用作运算符判定一个函数是否承诺不抛出异常。  
新增基础类型、容器类型、new分配内存时的列表初始化。构建临时变量时也可以直接使用列表初始化。  
可以直接对类内成员进行初始化/列表初始化。
### 3.11 C++对象模型
虚函数表解析
- 含有虚函数或其父类含有虚函数的类，编译器都会为其添加一个虚函数表，vptr。

虚基类表解析。
- 虚继承产生虚基类表(vbptr)，虚基类表的内容与虚函数表完全不同。

对象模型概述.
- 简单对象模型、表格驱动对象模型，以及非继承情况下的C++对象模型。

继承下的C++对象模型。  
分析C++类对象在下面情形中的内存布局：
- 单继承：子类单一继承自父类，分析了子类重写父类虚函数、子类定义了新的虚函数情况下子类对象内存布局。
- 多继承：子类继承于多个父类，分析了子类重写父类虚函数、子类定义了新的虚函数情况下子类对象内存布局，同时分析了非虚继承下的菱形继承。
- 虚继承：分析了单一继承下的虚继承、多重基层下的虚继承、重复继承下的虚继承。

## 4. STL  
> 子曾经曰过：要用好STL这个大轮子  

### 4.1 

## 5. Effective and More Effective Cpp
## 6. Python  
## 7. Linux环境与Shell
## 8. Linux服务器编程
### 8.1 线程安全的对象生命周期管理
用mutex来实现线程安全的类成员函数（如：单例模式的多线程计数count）。  
mutex并不能保护析构函数。  
一劳永逸的方法是采用引用计数型指针shared_ptr。  
C++中内存问题的主要原因：  
- 缓冲区溢出
- 空悬指针/野指针
- 重复释放
- 内存泄漏
- 不配对的new[]/delete  
- 内存碎片  
### 8.X epoll()和kqueue()的底层原理
网卡设备对应一个中断号, 当网卡收到网络端的消息的时候会向CPU发起中断请求, 然后CPU处理该请求. 通过驱动程序 进而操作系统得到通知, 系统然后通知epoll, epoll通知用户代码. 大致流程是这样。
作者：蓝形参
来源：[知乎](https://www.zhihu.com/question/20122137/answer/14049112)
著作权归作者所有，转载请联系作者获得授权。

首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。
不管是文件，还是套接字，还是管道，我们都可以把他们看作流。
之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？
阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。
非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”
很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。
大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。

为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。
假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。
假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。
但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。
假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”
也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。
这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。

然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。
于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：
while true {
for i in stream[]; {
if i has data
read until unavailable
}
}
我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。

为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:
while true {
select(streams[])
for i in streams[] {
if i has data
read until unavailable
}
}
于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。
但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次
说了这么多，终于能好好解释epoll了
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数，也有认为O(1)的[更新 1]）
在讨论epoll的实现细节之前，先把epoll的相关操作列出[更新 2]：
epoll\_create 创建一个epoll对象，一般epollfd = epoll\_create()
epoll\_ctl （epoll\_add/epoll\_del的合体），往epoll对象中增加/删除某一个流的某一个事件
比如
epoll\_ctl(epollfd, EPOLL\_CTL\_ADD, socket, EPOLLIN);//有缓冲区内有数据时epoll_wait返回
epoll\_ctl(epollfd, EPOLL\_CTL\_DEL, socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回
epoll\_wait(epollfd,...)等待直到注册的事件发生
（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。
一个epoll模式的代码大概的样子是：
while true {
active\_stream[] = epoll\_wait(epollfd)
for i in active\_stream[] {
read or write till unavailable
}
}

## 9. Web数据挖掘
## 10. 信息检索
## 1X. 其他知识点
### 1X.1 Redis
### 1X.2 Kafka
### 1X.3 Elasticsearch
### 1X.4 Vim
ctags cscope
### 1X.5 gcc、gdb、valgrind、makefile
### 1X.6 Docker
### 1X.7 局部敏感哈希
simhash主要分为5个步骤：分词、哈希、加权、合并、降维。
分词之后对每个词计算哈希值(01)串，按照分词之后的权重对01串进行加权（其中0看成-1）然后将每个向量加起来之后降维（负数看成0，正数看成1）即可得到哈希值。哈希值之间的比较主要通过汉民距离进行比较，在3以内即可说明相似度比较高。  
汉民距离：异或之后的结果的1的个数即为汉民距离的大小。  
大量simhash值的比较，将simhash签名分成4份，利用抽屉原理，至少一份是完全相同的。  
simhash的运用：网页存储、网页重复判定、视频网站的重复、网盘网站的秒传。  
### 1X.8 HDFS、Spark
### 1X.9 UML关系图
[讲解](http://blog.csdn.net/suxinpingtao51/article/details/8011335)  
### 1X.10 SQL语句总结
1.基本查询：   
(1)我只想查询某个表的某列时：SELECT col1,col2 from table1过滤掉不要的列字段;   
(2)我想查询某行的信息时：使用where col1=1 and col2=2来过滤掉不要的行;   
(3)我们可以使用group by来aggregate 数据，汇总时，显示的字段一般是汇总函数;   
(4)我们可以使用having来过滤掉汇总后的数据;   
(5)我们可以使用order by 来对我们查询的结果进行排序如 order by col2; 解释：select用来查询关键字段;distinct的关键字段返回的是唯一的结果 between a and b:用来限制一个值的范围；like：用来过滤某列的文本数据;in:某个值是否在里面   

2.数据操作：   
(1)我想更新表中col2等于2的col1值变为1的一行数据：update table1 set col1=1 where col2=2   
(2)我想手工给table1插入数据：insert into table(col1,col2) values(1,2);   
(3)查询插入数据，这个开发中一定用到:insert into table1(col1)select col2 from table2   

3.视图（使用到复杂的查询） create view view1 as select co1 from table1 使用时select from view1   
4.关联表查询：   
(1)左关联：所有的行都从主表出即使子表中没有，一般包括多的拿来当主表；   
(2)内连接：主表和子表都有的行；   
(3)右关联和左关联意思一样；   

5.关联查询更新数据（这个好像很厉害） update t1 set a=1 from table1 t1 join table2 t2 on t1.id=t2.id where t1.col1=0 and t2.col2 is null; 

6.子查询： select from table1 where id in(select id from table2 where date>current\_timestamp) 

7.索引 create index index1 on table1(id) 索引可以加速我们的delete和update的操作  

8.非常有用的工具函数   
(1)字符串变为日期类型：to\_date(oracle,postgresql)、str\_to\_date(musql)   
(2)返回第一个字段不是null的字段：coalesce(col1,col2,"defualt");   
(3)返回当前时间current_timestamp   
(4)对两个查询结果做运算：union(返回两个表的所有数据)except（所有的行必须只有主表有，子表不能有） intersect：连个表都有的行    

9.汇总函数： count：返回行数 sum：返回该列的所有和 avg：返回该列的平均值 min/max:返回该列的最大或者最小值 具体参考下图：

## 11. 项目相关






