# 1. 倒排索引布尔检索
词项-文档矩阵  
采用定长数组存储文档ID是不可行的  
通常采用变长表的方式（vector、list）
每个词项中按照docID排序  
布尔查询的处理：  
- AND查询，倒排记录表求交集，复杂度O(len1+len2)；  
- OR查询，倒排记录表求并集，复杂度O(1)；
- NOT查询，倒排记录表的减，复杂度O(len1+len2)；

布尔表达式的查询优化：
- AND查询，从长度最小的表开始合并；  
- 布尔表达式转化为合取范式，结合AND查询优化策略；

优缺点  
# 2. 词汇表与倒排记录表  
中文分词方法：  
- 词典：正向最大匹配和逆向最大匹配；新词问题二义问题；解决：规则+统计；  
- 规则+统计，条件随机场；
- 搜索引擎中的中文分词法：大词典+统计+启发式规则；  

去除停用词：词典  
现代搜索引擎倾向于不去除停用词：良好的索引压缩之后停用词占据资源很小，良好的查询优化策略之后不会增加查询开销，停用词有时候还是有大用处的。  
例子：to be or not to be.  
词条归一化成词项：同义词归一化，拼写错误处理，词形合并，词干还原
归一化工具：stemmer  
快速倒排记录表合并：skiplist  
短语查询：中国科学院：中国 AND 科学院 是不准确的  
解决方法：  
1.双词索引，两个词项合并成一个词项  
更长的短语查询：拆分成基于双词索引的布尔表达式  
扩展双词索引：对索引文档进行词性标注，满足词性规则的也划分为双词。例如catcher in the rye  
讲query也切分为扩展双词  
2.带位置信息的索引  
合并的时候考虑位置匹配，例子 to be or not to be.  
带位置信息的索引可处理临近查询，而双词索引则不能  
索引压缩可处理位置信息和双词索引带来的空间开销，一般是非位置索引的2-4倍。  
还可采用混合索引  
# 3. 词典与容错式检索
词项定位 两种数据结构：哈希表、树  
有些IR系统采用哈希表，有些IR系统采用树  
取决于词项数目，访问频次，更新频次  
哈希表的查询时间是常数，缺点：无法处理词项的变形和纠错、不支持前缀搜索、重新哈希。  
树：主要是B树，B+树。  
通配符查询的处理：  
1.mon\*采用B树查询非常容易，只需要返回mon子树的词项即可。    
\*mon可以将所有词项倒过来，构建一棵B树。  
通配符在中间的时候使用B树搜索的开销很大：mon\*st  
分别求满足mon\*和\*st的匹配词项，然后求交集，开销很大。  
2.轮排索引（轮排树）：  
将每个通配查询旋转，使得\*出现在末尾，将每个旋转之后的结果放在词典中。即在索引前面再加一层索引，索引用B树来组织。  
轮排索引的空间要大四倍以上。  
3.k-gram索引  
构建一个倒排索引，此时词典部分是所有的k-gram，倒排记录表部分是包含某个k-gram的所有词项  
相当于对词项再构建一个倒排索引(二级索引)  
2-gram拆分的例子：mon\*拆分成 $m AND mo AND on  
需要后续过滤：例如moon  
k-gram的空间消耗较小，轮排索引不需要后续过滤。  
拼写错误处理：  
两种拼写纠正的方法：词袋法，上下文敏感法。  
词袋法：单词间距离的计算：编辑距离(DP)、带权重的编辑距离(基于电脑键盘，手机键盘)、k-gram重叠率。  
k-gram拼写纠正：使用k-gram索引，根据jaccard相似度设定阈值减少匹配数目。  
上下文敏感的拼写纠正：统计结果、从历史检索库中检索  
基于发音的拼写错误：略  
拼写错误的处理：一般只给出一个结果，拼写错误检查的开销很大，但是拼写错误的检查，主流搜索引擎做的很好。  














