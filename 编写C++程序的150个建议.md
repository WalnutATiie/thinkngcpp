# 第一部分 语法篇
## 第一章 从C继承来的
### 建议0：不要让main函数返回void
main函数的标准定义方式：int main();int main(int argc,char * argv[]);以保证程序有良好的可移植性
### 建议1：区分0的四种面孔
(1)、整型0；(2)、空指针NULL，指针与int类型所占空间是一样的，都是32位；(3)、字符串结束标志’\0’；(4)、逻辑FALSE/TRUE是int类型，而false/true是bool类型。
### 建议2：避免那些由运算符引发的混乱
不要混淆=和==、&和&&、|与||这三对运算符之间的差别，针对=和==之间的问题，可以这样做：if(0 == nValue)。
### 建议3：对表达式计算顺序不要想当然
(1)、针对操作符优先级，建议多写几个括号；(2)、注意函数参数和操作数的评估求值顺序问题。
### 建议4：小心宏#define使用中的陷阱
(1)、用宏定义表达式时，要使用完备的括号：如 #define ADD(a, b) ((a)+(b))，每个参数都要用括号括起来；(2)、使用宏时，不允许参数发生变化；
(3)、用大括号将宏所定义的多条表达式括起来。
### 建议5：不要忘记指针变量的初始化
(1)、可以将其初始化为空指针0(NULL)；(2)、对于全局变量来说，在声明的同时，编译器会悄悄完成对变量的初始化。
### 建议6：明晰逗号分隔表达式的奇怪之处
(1)、在使用逗号分隔表达式时，C++会确保每个表达式都被执行，而整个表达式的值则是最右边表达式的结果；(2)、在C++中，逗号分隔表达式既可以用作左值，也可以用作右值。
### 建议7：时刻提防内存溢出
在调用C语言字符串金典函数(strcpy、strcat、gets等)时，要从源代码开始就提高警惕，尽量追踪传入数据的流向，向代码中的每一个假设提出质疑。在访问数据时，
注意对于边界数据要特殊情况特殊处理，还要对杜绝使用未初始化指针和失败后未置NULL的“野指针”。
### 建议8：拒绝晦涩难懂的函数指针
函数指针在运行时的动态调用(例如函数回调)中应用广泛。但是直接定义复杂的函数指针会由于有太多的括号而使代码的可读性下降。使用typedef可以让函数指针更直观和易维护。
### 建议9：防止重复包含头文件
为了避免重复包含头文件，建议在声明每个头文件时采用“头文件卫士”加以保护，比如采用如下的形式：  
\#ifndef\_\_SOMEFILE\_H\_\_  
\#define\_\_SOMEFILE\_H\_\_  
……  
\#endif  
### 建议10：优化结构体中元素的布局
把结构体中的变量按照类型大小从小到大依次声明，尽量减少中间的填充字节。结构体布局是保证类型的起始地址能够被该类型的字节数整除。
### 建议11：将强制转型减到最少
(1)、const\_cast\<T\*\>(a)：它用于从一个类中去除以下这些属性：const、volatile和\_\_unaligned；  
(2)、dynamic\_cast\<T\*\>(a)：它将a值转换成类型为T的对象指针，主要用来实现类层次结构的提升；  
(3)、reinterpret\_cast\<T\*\>(a)：它能够用于诸如One\_class\*到Unrelated\_class\*这样的不相关类型之间的转换，因此它是不安全的；  
(4)、static\_cast\<T\*\>(a)：它将a的值转换为模板中指定的类型T，但是，在运行时转换过程中，它不会进行类型检查，不能确保转换的安全性。  
### 建议12：优先使用前缀操作符
对于整型和长整型的操作，前缀操作和后缀操作的性能区别通常是可以忽略的。对于用户自定义类型，优先使用前缀操作符。
因为与后缀操作符相比，前缀操作符因为无须构造临时对象而更具性能优势。
### 建议13：掌握变量定义的位置与时机
在定义变量时，要三思而后行，掌握变量定义的时机与位置，在合适的时机于合适的位置上定义变量。尽可能推迟变量的定义，直到不得不需要该变量为止；
同时，为了减少变量名污染，提高程序的可读性，尽量缩小变量的作用域。
### 建议14：小心typedef使用中的陷阱
区分typedef与#define之间的不同；不要用理解宏的思维方式对待typedef，
typedef声明的新名称具有一定的封装性，更易定义变量。同时还要注意它是一个无“现实意义”的存储类关键字。  
### 建议15：尽量不要使用可变参数
 编译器对可变参数函数的原型检查不够严格，所以容易引起问题，难于查错，
 不利于写出高质量的代码。所以应当尽量避免使用C语言方式的可变参数设计，而用C++中更为安全的方式来完美代替之(如多态等)。
### 建议16：慎用goto
### 建议17：提防隐式转换带来的麻烦
提防隐式转换所带来的微妙问题，尽量控制隐式转换的发生；通常采用的方式包括：  
(1)、使用非C/C++关键字的具名函数，用operator as_T()替换operator T()(T为C++数据类型)。  
(2)、为单参数的构造函数加上explicit关键字。  
### 建议18：正确区分void与void\*
Void是“无类型”，所以它不是一种数据类型；void\*则为“无类型指针”，即它是指向无类型数据的指针，也就是说它可以指向任何类型的数据。
Void发挥的真正作用是限制程序的参数与函数返回值：  
(1)、如果函数没有返回值，那么应将其声明为void类型；  
(2)、如果函数无参数，那么声明函数参数为void。  
对于void\*，(1)、任何类型的指针都可以直接赋值给它，无须强制转型；(2)、如果函数的参数可以是任意类型指针，那么应声明其参数为void\*。
## 第2章 从C到C++，需要做出一些改变
### 建议19：明白在C++中如何使用C
若想在C++中使用大量现成的C程序库，就必须把它放到extern“C” {/* code */}中，extern “C”的作用就是告诉C++链接器寻找调用函数的符号时，
采用C的方式。要实现在C++代码中调用C的代码，具体方式有以下几种：(1)、修改C代码的头文件，当其中含有C++代码时，在声明中加入extern “C”；
(2)、在C++代码中重新声明一下C函数，在重新声明时添加上extern “C”；(3)、在包含C头文件时，添上extern “C”。
### 建议20：使用memcpy()系列函数时要足够小心
要区分哪些数据对象是POD(传统C风格的数据类型，C的所有对象都是POD，对于任何POD对象，我们都可以放心大胆地使用memset()、memcpy()、
memcmp()等函数对对象的内存数据进行操作)，
哪些是非POD(C++的对象可能并不是一个POD，如动多态)，由于非POD对象的存在，在C++中使用memcpy()系列函数时要保持足够的小心。
### 建议21：尽量用new/delete代替malloc/free
malloc与new之间的区别：  
(1)、new是C++运算符，而malloc则是C标准库函数；  
(2)、通过new创建的东西是具有类型的，而malloc函数返回的则是void*，需要进行强制转型；  
(3)、new可以自动调用对象的构造函数，而malloc不会；  
(4)、new失败是会调用new_handler处理函数，而malloc失败则直接返回NULL。  
Free与delete之间的区别：  
(1)、delete是C++运算符，free是C标准库函数；  
(2)、delete可以自动调用对象的析构函数，而malloc不会。另外，new/delete必须配对使用，malloc/free也一样。
### 建议22：灵活地使用不同风格的注释
### 建议23：尽量使用C++标准的iostream
### 建议24：尽量采用C++风格的强制转型
### 建议25：尽量用const、enum、inline替换#define
对于简单的常量,应该尽量使用const对象或枚举类型数据，避免使用#define；对于形似函数的宏，尽量使用内联函数，避免使用#define。
总之一句话，尽量将工作交给编译器，而不是预处理器。
### 建议26：用引用代替指针
C++中的引用，是编译器通过const指针实现的，但是这个实现对于程序员进行透明化处理。  
### 第三章 说说内存管理那些事儿
在VC中，栈空间未初始化的字符默认是-52，补码是0xCC，两个0xCC，即0xCCCC在GBK编码中就是“烫”；
堆空间未初始化的字符默认是-51，两个-51在GBK编码中就是“屯”。两者都是未初始化的内存。
### 建议27：区分内存分配的方式
一个程序要运行，就必须先将可执行的程序加载到计算机内存里，程序加载完毕后，就可以形成一个运行空间，按照代码区、数据区、堆区、栈区进行布局。代码区存放的是程序的执行代码；数据区存放的是全局数据、常量、静态变量等；堆区存放的则是动态内存，供程序随机申请使用；而栈区则存放着程序中所用到的局部数据。这些数据可以动态地反应程序中对函数的调用状态，通过其轨迹也可以研究其函数机制。  
在C++中，数据区又被分成自由存储区、全局/静态存储区和常量存储区，再加上堆区、栈区，也就是说，内存被分成了5个区。(1)、栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元将自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是所分配的内存容量有限；(2)、堆区：堆就是那些由new分配的内存块，其释放编译器不会管它，而是由我们的应用程序控制它，一般一个new就对应于一个delete，如果程序员没有释放掉，那么在程序结束后，操作系统就会自动回收；(3)、自由存储区：是那些由malloc等分配的内存块，它和堆十分相似，不过它是用free来结束自己生命的；(4)、全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有作此区分，它们共同占用同一块内存区；(5)、常量存储区：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。  
堆与栈的区别：(1)、管理方式不同：对于栈来讲，它是由编译器自动管理的，无须我们手工控制；对于堆来说，它的释放工作由程序员控制，容易产生memory leak；(2)、空间大小不同：一般来讲在32位系统下，堆内存可以达到4GB的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的；(3)、碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而产生大量的碎片，使程序效率降低。对于栈来讲，则不存在这个问题，其原因还要从栈的特殊数据结构说起。栈是一个具有严明纪律的队列，其中的数据必须遵循先进后出的规则，相互之间紧密排列，绝不会留给其他数据可插入之空隙，所以永远都不可能有一个内存块从栈中间弹出，它们必须严格按照一定的顺序一一弹出；(4)、生成方向：对于堆来讲，其生长方向是向上的，也就是向着内存地址增加的方向增长；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长的；(5)、分配方式：堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数完成，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放的，无须我们手工实现；(6)、分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：它会分配专门的寄存器存放栈的地址，而且压栈出栈都会有专门的指令来执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，则可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存了，然后返回。显然，堆的效率比栈要低得多。  
### 建议28：new/delete与new[]/delete[]必须配对使用
由于内置数据类型没有构造、析构函数，所以在针对内置数据类型时，释放内存使用delete或delete[]的效果都是一样的。  
### 建议29：区分new的三种形态
 (1)、如果是在堆上建立对象，那么应该使用new operator，它会为你提供最为周全的服务；  
 (2)、如果仅仅是分配内存，那么应该调用operator new，但初始化不在它的工作职责之内。如果你对默认的内存分配过程不满意，
 想单独定制，重载operator new是不二选择；  
 (3)、如果想在一块已经获得的内存里建立一个对象，那就应该用placement new。但是通常情况下不建议使用，
 除非是在某些对时间要求非常高的应用中，因为相对于其他两个步骤，选择合适的构造函数完成对象初始化是一个时间相对较长的过程。
### 建议30：new内存失败后的正确处理
当使用new申请一块内存失败时，抛出异常std::bad\_alloc是C++标准中规定的标准行为，所以推荐使用try{p=new int[SIZE];} catch(std::bad_alloc) {…} 的处理方式。
但是在一些老旧的编译器中，却不支持该标准，它会返回NULL，此时具有C传统的Test\_for\_NULL代码形式便起了作用。所以，要针对不同的情形采取合理的处置方式。
### 建议31：了解new_handler的所作所为
在使用operatornew申请内存失败后，编译器并不是不做任何的努力直接抛出std::alloc异常，在这之前，它会调用一个错误处理函数(这个函数被称为new-handler)，进行相应的处理。通常，一个好的new-handler函数的处理方式必须遵循以下策略之一：(1)、使更大块内存有效；(2)、装载另外的new-handler；(3)、卸载new-handler；(4)、抛出异常；(5)、无返回。
### 建议32：借助工具检测内存泄露问题
内存泄露一般指的是堆内存的泄露。检测内存泄露的关键是能截获对分配内存和释放内存的函数的调用。通过截获的这两个函数，我们就能跟踪每一块内存的生命周期。每当成功分配一块内存时，就把它的指针加入一个全局的内存链中；每当释放一块内存时，再把它的指针从内存链中删除。这样当程序运行结束的时候，内存链中剩余的指针就会指向那些没有被释放的内存。这就是检测内存泄露的基本原理。
### 建议33：小心翼翼地重载operator new/operator delete
通过重载operator new 和 operatordelete的方法，可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。但是是否选择重载operator new/delete 一定要深思熟虑。  
### 建议34：用智能指针管理通过new创建的对象
智能指针auto\_ptr，要使用它，需要包含memory头文件：(1)、auto\_ptr对象不可作为STL容器的元素；(2)、auto\_ptr缺少对动态配置而来的数组的支持；(3)、auto\_ptr在被复制的时候会发生所有权转移。  
### 建议35：使用内存池技术提高内存申请效率与性能
经典的内存池技术，是一种用于分配大量大小相同的小对象的技术。通过该技术可以极大地加快内存分配/释放过程。内存池技术通过批量申请内存，降低了内存申请次数，从而节省了时间。
## 第4章 重中之重的类
### 建议36：明晰class与struct之间的区别
C中的struct是一种数据类型。C++中struct被看成是一个对象，它可以包含函数，可以拥有构造函数、析构函数，同样拥有继承等能力。
C++中的class与struct差别：(1)、class和struct如果定义了构造函数，就都不能用大括号进行初始化了；如果没有定义，struct可以用大括号初始化，而class只有在所有成员变量全是public的情况下，才可以用大括号进行初始化；(2)、关于默认访问权限：class中默认的成员访问权限是private的，而struct中则是public的；(3)、关于继承方式：class继承默认是private继承，而struct默认是public继承。
### 建议37：了解C++悄悄做的那些事
对于类，编译器会悄悄地完成很多事：隐式产生一个类的默认构造函数，拷贝构造函数，拷贝赋值运算符和析构函数。对于特殊的空类，为了能够实现对空类的实例化，编译器还是会强制其sizeof大小为1。      
### 建议38：首选初始化列表实现类成员的初始化
类成员的初始化可采用两种形式来完成：在构造函数体重赋值完成和用初始化类成员列表完成：(1)、const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内被赋值；(2)、如果类B中含有A类型的成员变量，而类A中又禁止了赋值操作，此时要想顺利地完成B中成员变量的初始化，就必须采用初始化列表方式。即使没有禁用赋值操作，还是不推荐采用函数体内的赋值初始化方式。因为这种方式存在着两种问题。第一，比起初始化列表，此方式效率偏低；第二，留有错误隐患。
对于初始化列表，初始化的顺序与构造函数中的赋值方式不同，初始化列表中成员变量出现的顺序并不是真正初始化的顺序，初始化的顺序取决于成员变量在类中的声明顺序。只有保证成员变量声明的顺序与初始化列表顺序一致才能真正保证其效率。
### 建议39：明智地拒绝对象的复制操作
在某些需要禁止对象复制操作的情形下，可以将这个类相应的拷贝构造函数、赋值操作符operator = 声明为private，并且不要给出实现。或者采用更简单的方法：使用boost::noncopyable作为基类。  
### 建议40：小心，自定义拷贝函数
如果类内部出现了动态配置的资源，我们就不得不自定义实现其拷贝函数了。在自定义拷贝函数时，应该保证拷贝一个对象的All Parts:所有数据成员及所有的基类部分。  
### 建议41：谨防因构造函数抛出异常而引发的问题
判断构造对象成功与否，解决办法：抛出一个异常。构造函数抛出异常会引起对象的部分构造，因为不能自动调用析构函数，在异常发生之前分配的资源将得不到及时的清理，进而造成内存泄露问题。所以，如果对象中涉及了资源分配，一定要对构造之中可能抛出的异常做谨慎而细致的处理。  
### 建议42：多态基类的析构函数应该为虚
虚函数的最大目的就是允许派生类定制实现。所以，用基类指针删除一个派生类对象时，C++会正确地调用整个析构链，执行正确的行为，以销毁整个对象。在实际使用虚析构函数的过程中，一般要遵守以下规则：当类中包含至少一个虚函数时，才将该类的析构函数声明为虚。因为一个类要作为多态基类使用时，它一定会包含一个需要派生定制的虚函数。相反，如果一个类不包含虚函数，那就预示着这个类不能作为多态基类使用。同样，如果一个类的析构函数非虚，那你就要顶住诱惑，决不能继承它，即使它是“出身名门”。比如标准库中的string、complex、以及STL容器。
多态基类的析构函数应该是virtual的，也必须是virtual的，因为只有这样，虚函数机制才会保证派生类对象的彻底释放；如果一个类有一个虚函数，那么它就该有一个虚析构函数；如果一个类不被设计为基类，那么这个类的析构就应该拒绝为虚。
### 建议43：绝不让构造函数为虚
虚函数的工作机制：虚函数的多态机制是通过一张虚函数表来实现的。在构造函数调用返回之前，虚函数表尚未建立，不能支持虚函数机制，所以构造函数不允许设为虚。  
### 建议44：避免在构造/析构函数中调用虚函数
成员函数、包括虚成员函数，都可以在构造、析构的过程中被调用。当一个虚函数被构造函数(包括成员变量的初始化函数)或者析构函数直接或间接地调用时，调用对象就是正在构造或者析构的那个对象。其调用的函数是定义于自身类或者其基类的函数，而不是其派生类或者最低派生类的其他基类的重写函数。
如果在构造函数或析构函数中调用了一个类的虚函数，那它们就变成普通函数了，失去了多态的能力。
当在构造函数中调用虚函数时，由于先调用基类的构造函数，而此时子类还没有完全创建，虚函数表指针都没有创建，此时调用的虚函数并不是子类的虚函数。  
析构函数与之类似，执行哪个虚函数取决于其被绑定到哪里。析构顺序遵从的是从继承类到基类析构，一旦派生类的数据析构，在基类虚构函数中调用的虚函数就没有了多态的能力。
### 建议45：默认参数在构造函数中给你带来的喜与悲
合理地使用默认参数可以有效地减少构造函数中的代码冗余，让代码简洁而有力。但是如果不够小心和谨慎，它也会带来构造函数的歧义，增加你的调试时间。重载函数的二义性。
### 建议46：区分Overloading、Overriding、Hiding之间的差异
重载(Overloading)：是指同一作用域的不同函数使用相同的函数名，但是函数的参数个数或类型不同；2、重写(Overriding)：是指在派生类中对基类中的虚函数重新实现，即函数名和参数都一样，只是函数的实现体不一样，派生类对基类中的操作进行个性化定制就是重写。重写需要注意的问题：(1)、函数的重写与访问层级(public、private、protected)无关；(2)、const可能会使虚成员函数的重写失效；(3)重写函数必须和原函数具有相同的返回类型；3、隐藏(Hiding)：是指派生类中的函数屏蔽基类中具有相同名字的非虚函数。
hiding：在调用一个类的成员函数是，编译器会沿着类的继承链逐级地向上查找函数的定义，如果找到就停止。
### 建议47：重载operator=的标准三步走
由编译器完成的赋值运算符重载函数只是简单地将原对象位于stack中的域逐位地拷贝，赋值给新对象。如果对象存在于heap上的话，这种没有群浅拷贝和深拷贝的重载方式就会出现问题。
1、不要让编译器帮你重载赋值运算符；2、一定要检查自赋值；3、赋值运算符重载需返回*this的引用，引用之于对象的优点在于效率，为了能够更加灵活地使用赋值运算符，选择返回引用绝对是明智之举；4、赋值运算符重载函数不能被继承。如果需要给类的数据成员动态分配空间，则必须实现赋值运算符。
### 建议48：运算符重载，是成员函数还是友元函数
运算符重载的四项基本原则：(1)、不可臆造运算符；(2)、运算符原有操作数的个数、优先级和结合性不能改变；(3)、操作数中至少一个是自定义类型；(4)、保持重载运算符的自然含义。
运算符的重载可采用两种形式：成员函数形式和友元函数形式。(1)、重载为成员函数时，已经隐含了一个参数，它就是this指针；对于双目运算符，参数仅有一个；(2)、当重载友元函数时，将不存在隐含的参数this指针；如果运算符被重载为友元函数，那么它就获得一种特殊的属性，能够接受左参数和右参数的隐式转换，如果是成员函数版的重载则只允许右参数的隐式转换。一般说来，建议遵守一个不成文的规定：对双目运算符，最好将其重载为友元函数，因为这样更方便些；而对于单目运算符，则最好重载为成员函数。重载输出运算符<<时只能重载为友元函数。  
### 建议49：有些运算符应该成对实现
为了更好地适应使用习惯，很多运算符重载时最好成对实现，比如==与!=、<与>、<=与>=、+与+=、-与-=、\*与\*=、/与/=。
### 建议50：特殊的自增自减运算符重载
后缀操作重载时返回值应该为一个const对象。
### 建议51：不要重载operator&&、operator||以及operator,
### 建议52：合理地使用inline函数来提高效率
内联函数具有与宏定义相同的代码效率，但在其他方面却要优于宏定义。因为内联函数还遵循函数的类型和作用域规则。内联函数一般情况下都应该定义在头文件中。内联函数的定义分为两种方式：(1)、显示方式：在函数定义之前添加inline关键字，内联函数只有和函数体声明放在一起时inline关键字才具有效力；(2)、隐式方式：将函数定义于类的内部。一个给定的函数是否得到内联，很大程度上取决于你正在使用的编译器。   
使用内联函数应该注意：(1)、内联函数的定义必须出现在内联函数第一次被调用之前。所以，它一般会置于头文件中；(2)、在内联函数内不允许用循环语句和开关语句，函数不能过于复杂；(3)、依据经验，内联函数只适合于只有1~5行的小函数；(4)、对于内存空间有限的机器而言，慎用内联。过分地使用内联会造成函数代码的过度膨胀，会占用太多空间；(5)、不要对构造/析构函数进行内联；(6)、大多开发环境不支持内联调试，所以为了调试方便，不要将内联优化放在调试阶段之前。
### 建议53：慎用私有继承
私有继承会使基类的所有东西(包括所有的成员变量与成员函数)在派生类中变成private的，也就是说基类的全部在派生类中都只能作为实现细节，而不能成为接口。私有继承意味着“只有implementation 应该被继承，interface应该被忽略”，代表着是“is-implemented-in-terms-of”的内在关系。通常情况下，这种关系可以采用组合的方式来实现，并提倡优先使用组合的方案。但是如果存在虚函数和保护成员，就会使组合方案失效，那就应使用私有继承。  
### 建议54：抵制MI的糖衣炮弹
MI(多重继承)意味着设计的高复杂性、维护的高难度性，尽量少使用MI。  
### 建议55：堤防对象切片
多态的实现必须依靠指向同一类族的指针或引用。否则，就可能出现著名的对象切片(Object Slicing)问题。所以，在既有继承又有虚函数的情况下，一定要提防对象切片问题。
### 建议56：在正确的场合使用恰当的特性
 (1)、虚函数：虚函数机制的实现是通过虚函数表和指向虚函数表的指针来完成的。关键字virtual告诉编译器该函数应该实现晚绑定，编译器对每个包含虚函数的类创建虚函数表VTable，以放置类的虚函数地址。编译器密码放置了指向虚函数表的指针VPtr，当多态调用时，它会使用VPtr在VTable表中查找要执行的函数地址；(2)、多重继承：对于多重继承来说，对象内部会有多个VPrt，所以这就使偏移量计算变得复杂了，而且会使对象占用的空间和运行时开销都变大；(3)、虚基类：它与多重继承的情况类似，因为虚基类就是为了多重继承而产生的；(4)、运行时类型检测(RTTI)：是我们在程序运行时得到对象和类有关信息的保证。
### 建议57：将数据成员声明为private
将数据成员声明为private是具有相当充分的理由的：(1)、实现数据成员的访问控制；(2)、在将来时态下设计程序，为之后的各种实现提供弹性；(3)、保持语法的一致性。  
### 建议58：明晰对象的构造与析构的顺序
(1)、对象的构造都是从类的最根处开始的，由深及浅，先基类后子类，层层构造，这个顺序不能改变。如果含有多个基类，那么就按照声明顺序由前及后执行。析构函数则严格按照构造的逆序执行；(2)、成员对象构造函数的调用顺序与成员对象的声明顺序严格一致，析构顺序是构造顺序的严格逆序。这是因为类的声明是绝对唯一的，而类的构造函数可以有多个，所以按照声明才会使析构函数得到唯一的逆序；(3)、如果继承遇到成员对象，基类构造函数依然会被首先调用，然后调用成员对象的构造函数。  
### 建议59：明了如何在主调函数启动前调用函数
如果想在主程序main启动之前调用某些函数，调用全局对象的构造函数绝对是一个很不错的方法。因为从概念上说，全局对象是在程序开始前已经完成了构造，而在程序执行之后才会实施析构。  
在应用程序执行时，系统会县调用Startup，完成函数库的初始化，进程信息的设立，IO Stream产生，以及对static对象的初始化等操作，然后Startup调用main函数，把控制权交给main函数。main函数执行完毕之后，控制权又交回给startup。  
## 第5章   用好模板，向着GP(泛型编程)开进
### 建议60：审慎地在动、静多态之间选择
虚函数机制配合继承机制，生效于运行期，属于晚绑定，是动多态；而模板将不同的行为和单个泛化记号相关联发生在编译期，属于早绑定，被称为静多态。(1)、动多态：它的技术基础是继承机制和虚函数，它在继承体系之间通过虚函数表来表达共同的接口；(2)、静多态：它的技术基础是模板。与动多态相比，静多态始终在和参数“较劲儿”，它适用于所有的类，与虚函数无关。从应用形式上看，静多态是发散式的，让相同的实现代码应用于不同的场合；动多态是收敛式的，让不同的实现代码应用于相同的场合。从思维方式上看，前者是泛型式编程风格，它看重的是算法的普适性；后者是对象式编程风格，它看重的是接口与实现的分离度。两者区别：(1)、动多态的函数需要通过指针或引用传参，而静多态则可以传值、传指针、传引用等，“适应性”更强；(2)、在性能上，静多态优于动多态，因为静多态无间接访问的迂回代码，它是单刀直入的；(3)、因为实现多态的先后顺序不同，所以如果出现错误，它们抛出错误的时刻也不一样，动多态会在运行时报错，而静多态则在编译时报错。
### 建议61：将模板的声明和定义放置在同一个头文件里
模板类型不是一种实类型，它必须等到类型绑定后才能确定最终类型，所以在实例化一个模板时，必须要能够让编译器“看到”在哪里使用了模板，而且必须要看到模板确切的定义，而不仅仅是它的声明，否则将不能正常而顺利地产生编译代码。函数模板、类模板不同于一般的函数、类，它们不能像一般的方式那样进行声明与定义，标准要求模板的实例化与定义体必须放在同一翻译单元中。实现这一目标有三种方法(将模板的声明和定义都放置在同一个.h文件中；按照旧有的习惯性做法来处理，声明是声明，实现是实现，二者相互分离，但是需要包含头文件的地方做一些改变，如，在使用模板时，必须用#include “Temp.cpp”替换掉#include “Temp.h”；使用关键字export来定义具体的模板类对象和模板函数)，但是最优策略还是：将模板的声明和定义都放置在同一个.h文件中，虽然在某种程度上这破坏了代码的优雅性。  
### 建议62：用模板替代参数化的宏函数
参数化的宏函数有着两个致命缺点：(1)、缺乏类型检查；(2)、有可能在不该进行宏替换的时候进行了替换，违背了作者的意图。模板是实现代码复用的一种工具，它可以实现类型参数化，达到让代码真正复用的目的。  
### 建议63：区分函数模板与模板函数、类模板与模板类
 函数模板的重点在于“模板”两个字，前面的“函数”只是一个修饰词。其表示的是一个专门用来生产函数的模板。而模板函数重点在“函数”，表示的是用模板所生成的函数。函数模板的一般定义形式为：
Template\<class数据类型参数标识符\>  
返回类型标识符 函数名(数据类型参数标识符 形参)  
{  //… …}  
将函数模板的模板参数实例化后会生成具体的函数，此函数就是模板函数。由函数模板所生成的模板函数的一般形式为：  
函数名<数据类型参数标识符>(数据类型参数标识符 形参)  
类模板是为类定义的一种模式，它使类中的一些数据成员和成员函数的参数或返回值可以取任意的数据类型。在类定义中，凡是采用标准数据类型的数据成员、成员函数的参数前面都要加上类型标识符，在返回类型前也要进行同样的处理。如果类中的成员函数要在类的声明之外定义，则它必须是模板函数。将类模板的模板参数实例化后生成的具体类，就是模板类。函数模板和类模板处于实例化之前，而模板 函数或模板类则在实例化之后。  
### 建议64：区分继承与模板
模板的长处在于处理不同类型间“千篇一律”的操作。相较于类继承，这些类不必具有什么相同的性质。
## 第6章 让神秘的异常处理不再神秘
### 建议65：使用exception来处理错误
异常能：(1)、增强程序的健壮性；(2)、使代码变得更简洁优美、更易维护；(3)、错误信息更灵活、丰富。
### 建议66：传值throw异常，传引用catch异常
throw by value, pass by reference
### 建议67：用“throw;”来重新抛出异常
对于异常的重新抛出，需要注意：(1)、重新抛出的异常对象只能出现在catch块或catch调用的函数中；(2)、如果在处理代码不执行时碰到“throw;”语句，将会调用terminate函数。  
  
